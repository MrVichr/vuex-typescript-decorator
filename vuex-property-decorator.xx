import * as Vuex from "vuex";

export const $vuexts=Symbol("$vuexts");

class PropertyInfo
 {
  propertyKey: string;
  descriptor: PropertyDescriptor;
  public constructor(propertyKey: string, descriptor: PropertyDescriptor)
   {
    this.propertyKey=propertyKey;
    this.descriptor=descriptor;
   }
 }

class GetterInfo extends PropertyInfo { }

class ActionInfo extends PropertyInfo { }

class MutationInfo extends PropertyInfo
 {
  blesk: number;
 }

class HiddenInfo
 {
  propertyKey: string;
  descriptor?: PropertyDescriptor;
  public constructor(propertyKey: string, descriptor?: PropertyDescriptor)
   {
    this.propertyKey=propertyKey;
    this.descriptor=descriptor;
   }
 }


class StoreInfo
 {
  target: any;
  getters: GetterInfo[]=[];
  actions: ActionInfo[]=[];
  mutations: MutationInfo[]=[];
  hiddens: HiddenInfo[]=[];
  public constructor(target: any)
   {
    this.target=target;
   }
 }

var centralStore: StoreInfo[]=[];
function findStore(target: any): StoreInfo
 {
  let res=centralStore.find(function(si: StoreInfo) {return si.target==target;});
  if (res)
    return res;
  let res2=new StoreInfo(target);
  centralStore.push(res2);
  return res2;
 }

function findStoreC(ctr: Function): StoreInfo|undefined
 {
  return centralStore.find(function(si: StoreInfo) {return si.target.constructor==ctr;});
 }

function getter_inner(target: any, propertyKey: string, descriptor: PropertyDescriptor): PropertyDescriptor
 {
  if (!descriptor)
    throw Error("The Property Descriptor will be undefined if your script target is less than ES5");;
  //console.log('got getter, target=', target, 'prop=', propertyKey, 'descriptor=', descriptor);
  let si=findStore(target);
  //if you use both @getter and get then we're called twice
  if (!si.getters.find(function(gi) {return gi.propertyKey==propertyKey;}))
    si.getters.push(new GetterInfo(propertyKey, descriptor));
  if (descriptor.get || descriptor.set) //for get property()
    return {...descriptor,
      get: function(this: VuextsMixin<any>) //called by user, thinking s/he calls his own method
         {
          //console.log("getter_inner("+propertyKey+"): this=", this);
          let vi=this[$vuexts]; //((this as any).$vuexts as VuextsInfo<any>);
          if (vi.store.getters)
            return vi.store.getters[propertyKey];
          return undefined;
         }}
  else //for @getter get_property()
    return {...descriptor,
      value: function(this: VuextsMixin<any>) //called by user, thinking s/he calls his own method
         {
          //console.log('getter_inner: this=', this);
          let vi=this[$vuexts];
          if (vi.store.getters)
            return vi.store.getters[propertyKey];
          return undefined;
         }}
 }

//decorate as @getter
function getter(target: any, propertyKey: string, descriptor: PropertyDescriptor)
 {
  return getter_inner(target, propertyKey, descriptor);
 }

//decorate as @getter()
/*function getter()
 {
  return getter_inner;
 }*/

export { getter }; //cannot have both @getter and @getter() under same name... probably

function action_inner(target: any, propertyKey: string, descriptor: PropertyDescriptor): PropertyDescriptor
 {
  if (!descriptor)
    throw Error("The Property Descriptor will be undefined if your script target is less than ES5");;
  //console.log('got action, target=', target, 'prop=', propertyKey);
  let si=findStore(target);
  si.actions.push(new ActionInfo(propertyKey, descriptor));
  return {...descriptor,
    value: function(this: VuextsMixin<any>, /*context: null,*/ payload: any) //called by user, thinking s/he calls his own method
       {
        //console.log('action_inner: this=', this);
        let vi=this[$vuexts];
        vi.store.dispatch(propertyKey, payload);
       }}
 }

//decorate as @action
function action(target: any, propertyKey: string, descriptor: PropertyDescriptor)
 {
  return action_inner(target, propertyKey, descriptor);
 }

//decorate as @action()
/*function action()
 {
  return action_inner;
 }*/

export { action }; //cannot have both @action and @action() under same name... probably

function mutation_inner(target: any, propertyKey: string, descriptor: PropertyDescriptor): PropertyDescriptor
 {
  if (!descriptor)
    throw Error("The Property Descriptor will be undefined if your script target is less than ES5");;
  //console.log('got mutation, target=', target, 'prop=', propertyKey);
  let si=findStore(target);
  si.mutations.push(new MutationInfo(propertyKey, descriptor));
  return {...descriptor,
    value: function(this: VuextsMixin<any>, payload: any) //called by user, thinking s/he calls his own method
       {
        //console.log('mutation_inner: this=', this);
        let vi=this[$vuexts];
        let result: any=vi.store.commit(propertyKey, payload); //undefined
        //console.log("Vuexts: mutation_inner returns ", result);
        return result;
       }};
 }

//decorate as @mutation
function mutation(target: any, propertyKey: string, descriptor: PropertyDescriptor)
 {
  return mutation_inner(target, propertyKey, descriptor);
 }

//decorate as @mutation()
/*function mutation()
{
 return mutation_inner;
}*/

export { mutation };

function hidden_inner(target: any, propertyKey: string, descriptor?: PropertyDescriptor, options?: {hi: string}): PropertyDescriptor
 {
  //oh dear, how do I tell @hidden property from ES<5 ?
  //if (!descriptor)
    //throw Error("The Property Descriptor will be undefined if your script target is less than ES5");;

  //console.log('got mutation, target=', target, 'prop=', propertyKey);
  let si=findStore(target);
  si.hiddens.push(new HiddenInfo(propertyKey, descriptor));
  return {...descriptor, enumerable: false}; //return value ignored for properties (i.e. not getter+setter)
 }

function hidden(target: any, propertyKey: string, descriptor: PropertyDescriptor): PropertyDescriptor; //@hidden get/set
function hidden(target: any, propertyKey: string): void; //@hidden x: number
//function hidden(target: any, propertyKey: string, descriptor: PropertyDescriptor): PropertyDescriptor;
function hidden(options?: {hi: string}): (target: any, propertyKey: string, descriptor?: PropertyDescriptor)=>any;//PropertyDescriptor;
function hidden(options?: {hi: string}): (target: any, propertyKey: string)=>void;
function hidden(target?: any, propertyKey?: string, descriptor?: PropertyDescriptor)
 {
  if (target && propertyKey)
   {
    if (descriptor)
      return hidden_inner(target, propertyKey, descriptor, undefined);
    hidden_inner(target, propertyKey, undefined, undefined);
    return;
    //let target: (new(...args: any[])=>T)=options;
   };
  //throw new Error("frilure");

  return function (target2: any, propertyKey: string, descriptor?: PropertyDescriptor): PropertyDescriptor|void
   {
    let result=hidden_inner(target2, propertyKey, descriptor, target);
    //console.log("Vuexts: hidden factory tg2=", target2, "prop=", propertyKey, "desc=", descriptor, "res=", result);
    if (descriptor)
      return result;
    return; //return value is NOT ignored. Must return undefined.
   };
 }

export { hidden };

/*class StoreWrapper
 {
  vuex: Vuex.Store<any>;
  appS: any;
  constructor()
   {
   }
 }*/

class VuextsInfo<T>
 {
  store: Vuex.Store<T>;
  constructor()
   {
   }
 }

type VuextsMixin<X>=
 {
  [$vuexts]: VuextsInfo<X>;
 }

type Ctor<X> =
 {
  new(...args: any[]): X;
 };

//see https://stackoverflow.com/questions/49868048/class-decorator-with-generic-parameter
function store_inner<T>(ctr: new(...args: any[])=>T, options?: Vuex.StoreOptions<T>)
 {
  // give a name to the extended T we will return
  /**/
  type XT = T & VuextsMixin<T>;
   /*{
    $vuexts: VuextsInfo<XT>;
   };*/
  /*/
  class XT extends (T as Ctor<any>)
   {
    $vuexts: VuextsInfo<XT>;
   };
  /**/

  
  let orioptions: Vuex.StoreOptions<T>=options || {};
  let si=findStoreC(ctr);
  //console.log('got class, ctr=', ctr, 'si=', si);
  if (!si)
   {
    console.error("Vuexts: @store should have at least one @action or @mutation or @getter");
    //return ctr; //should not happen
   };

  //find getters and add them to si.getters
  //inspired by vue-class-component/lib/component.js#componentFactory
  var proto = ctr.prototype;
  Object.getOwnPropertyNames(proto).forEach(function (key)
   {
    if (key === 'constructor') {
      return;
     }
    // known properties
    if ([""].indexOf(key) > -1) {
      //si.something = proto[key];
      return;
    }
    var descriptor = Object.getOwnPropertyDescriptor(proto, key);
    //    if (typeof descriptor.value === 'function') {
    //        // methods
    //        (options.methods || (options.methods = {}))[key] = descriptor.value;
    //    }
    //else
    if (si && descriptor && (descriptor.get || descriptor.set))
     {
      let ishidden=si.hiddens.find(function(hi: HiddenInfo) {return hi.propertyKey==key;});
      if (!ishidden) //do not convert @hidden getter into Vuex getter
       {
        // computed properties
        let descriptor2=getter_inner(si.target, key, descriptor);
        Object.defineProperty(proto, key, descriptor2);
       };
     };
   }); 


  //replace constructor to add $vuexts and create store
  // first assertion: ctr as Ctor<any>
  const sub = class VuexTS_Store extends (ctr as Ctor<any>)
   {
    [$vuexts]: VuextsInfo<T>;//<XT>
    constructor (...args:any[])
     {
      super(...args);
      //disable enumerable to allow deep copy of this (contains cycle)   this.$vuexts=new VuextsInfo<XT>();
      //replaced with Symbol Object.defineProperty(this, "$vuexts", {enumerable: false, value: new VuextsInfo<XT>()});
      this[$vuexts]=new VuextsInfo<T>();
      // second assertion: this as XT
      let that=this as any as XT;
      let adjustedOptions: Vuex.StoreOptions<T>;//<XT>;
      adjustedOptions=orioptions as Vuex.StoreOptions<T>;//<XT>;
      if (si)
       {
        adjustedOptions=adjustOptions<T>(that, adjustedOptions, si);
        for (let hid of si.hiddens)
         {
          //already initialized
          if (hid.descriptor===undefined)
           {
            //console.log("Vuexts store: defining property", hid, "value=", this[hid.propertyKey]);
            Object.defineProperty(this, hid.propertyKey, {enumerable: false, value: this[hid.propertyKey]});
           }
          else
           {
            //it is, by doing nothing   console.warn("Vuexts: @hidden get/set not implemented");
           }
         }
       };
      //console.log('ctr store: what\'s diff between ', that, ' and ', T.toString());
      this[$vuexts].store=new Vuex.Store<XT>({...adjustedOptions,
        state: function()
         {
          return (that);
         }
       });
     }
   // final assertion: sub as Ctor<XT>
   } as Ctor<XT>;
  return sub;
}

/** Only accepts @store or @store(options). Does not accept @store().
 * 
 * @param options additional store options e.g. {plugins: ..., modules: ...}
 */
//function store<T>(options: Vuex.StoreOptions<T>): (<CtorOfT extends Ctor<T>>(ctr: CtorOfT) => Ctor<T>);
function store<T>(options?: Vuex.StoreOptions<T>): <CtorOfXT extends Ctor<T>>(ctr: CtorOfXT) => CtorOfXT;
//function store<T>(ctr: (new(...args: any[])=>T)): Ctor<T>;
function store<T>(ctr: Ctor<T>): Ctor<T>;
function store<T>(options?: Vuex.StoreOptions<T>|Ctor<T>)//(new(...args: any[])=>T))
 {
  //for @store(...), this==undefined

  if (typeof options=="function")
   {
    let ctr: (new(...args: any[])=>T)=options;
    return store_inner<T>(ctr, {});
   };
//  throw new Error("frilure");

  return function <CtorOfT extends Ctor<T>>(ctr: CtorOfT)//new(...args:any[])=>{})
   {
    return store_inner<T>(ctr, options as Vuex.StoreOptions<T>|undefined);
   };
 }

export {store};

function adjustOptionsStore<S>(that: S, opts: Vuex.StoreOptions<S>, si: StoreInfo): Vuex.StoreOptions<S>
 {
  let res: Vuex.StoreOptions<S>={...(opts as Vuex.StoreOptions<S>)};

  let getters: any={};
  si.getters.forEach(function (g: GetterInfo)
   {
    getters[g.propertyKey]=function(state: Vuex.Store<S>, getters: any, rootState: Vuex.Store<S>, rootGetters: any)
       {
        //console.log('getter '+g.propertyKey+': that=', that);
        if (g.descriptor.get)
          return g.descriptor.get.call(that);
        else
          return g.descriptor.value.call(that); //perhaps just g.descriptor.value or test typeof .value==="function"
       };
   });
  res.getters=getters;

  let actions: any={};
  si.actions.forEach(function (a: ActionInfo)
   {
    /*
     setStations: function(context, payload)
         {
          context.commit("SET_STATIONS", payload);
         }    */
    //console.log('gluing action, args=', a.descriptor.value.arguments, 'asstring=', a.descriptor.value.toString());
    //cannot log a.descriptor.value.arguments because
    //  Uncaught TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them
    //console.log('gluing action, asstring=', a.descriptor.value.toString());
    actions[a.propertyKey]=function(context: any, payload: any)
       {
        //we could bind to 'context' but it has pretty much the same content as 'that'
        //and 'that' makes way more sense
        let res=a.descriptor.value.call(that, /*context, */payload);
        let asPromise=Promise.resolve(res);
        if (asPromise==res) //was a promise
          asPromise.catch(function(err)
           {
            console.error('Vuexts.action '+a.propertyKey+': exception', err);
           });
       };
   });
  res.actions=actions;

  let mutations: any={};
  si.mutations.forEach(function (m: MutationInfo)
   {
    /*
     SET_STATIONS: function (state, payload)
         {
          state.stations=payload;
         }    */
    //console.log('gluing mutation, asstring=', m.descriptor.value.toString());
    mutations[m.propertyKey]=function(state: S, payload: any)
       {
        //yep, state==that   console.log('mutation '+m.propertyKey+": that=",that,"state=",state);
        let result: any=m.descriptor.value.call(that, payload);
        //console.log("Vuexts: mutation "+m.propertyKey+" returns ", result);
        return result;
       };
   });
  res.mutations=mutations;

  return res;
 }
/* not going to work
export function $vuexts<S>(): VuextsInfo<S>
 {
  if ((this as VuextsMixin<S>).$vuexts)
   {
    return this.$vuexts as VuextsInfo<S>;
   };
  console.error('$vuexts called on this=', this);
  throw new Error('$vuexts called on a non-store');
 }
*/

/**
 * Converts Vuex $store to decorated store
 * @param t E.g. this.$store
 */
export function getStore<T>(t: any): T
 {
  if (!t.state)
    throw Error("Vuexts.getStore called with not a store");
  let res=t.state as T&VuextsMixin<T>;
  if (!res || !res[$vuexts] || (res[$vuexts].store!=t))
   {
    console.error("Vuexts.getStore called with a non-decorated store");
    //cannot return undefined from getStore()   return;
   };
  return res;
 }

/**
 * Convert decorated store S to Vuex.Store<S> for Vue constructor
 * @param AppStore Decorated store instance
 */
export function asVuex<S>(AppStore: S): Vuex.Store<S>|undefined
 {
  //console.log('asVuex: AppStore=', AppStore);//, 'centralStore=', centralStore);
  if ((AppStore as any as VuextsMixin<S>)[$vuexts])
    return (AppStore as any as VuextsMixin<S>)[$vuexts].store;
  //if they didn't decorate
  console.error('Cannot convert non-decorated store to Vuex store', AppStore);
  return undefined;
 }